from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple

from ..tokens import Doc, Span
from .alignment import Alignment

def annotations_to_doc(
    vocab,
    tok_annot,
    doc_annot,
) -> Doc: ...
def validate_examples(
    examples: Iterable[Example],
    method: str,
) -> None: ...
def validate_get_examples(
    get_examples: Callable[[], Iterable[Example]],
    method: str,
): ...

class Example:
    x: Doc
    y: Doc

    def __init__(
        self,
        predicted: Doc,
        reference: Doc,
        *,
        alignment: Optional[Alignment] = None,
    ): ...
    def __len__(self) -> int: ...
    @property
    def predicted(self) -> Doc: ...
    @predicted.setter
    def predicted(self, doc: Doc) -> None: ...
    @property
    def reference(self) -> Doc: ...
    @reference.setter
    def reference(self, doc: Doc) -> None: ...
    def copy(self) -> Example: ...
    @classmethod
    def from_dict(cls, predicted: Doc, example_dict: Dict) -> Example: ...
    @property
    def alignment(self) -> Alignment: ...
    def _get_aligned_vectorized(self, align, gold_values): ...
    def _get_aligned_non_vectorized(self, align, gold_values): ...
    def get_aligned(self, field, as_string=False): ...
    def get_aligned_parse(self, projectivize=True): ...
    def get_aligned_sent_starts(self): ...
    def get_aligned_spans_x2y(self, x_spans, allow_overlap=False): ...
    def get_aligned_spans_y2x(self, y_spans, allow_overlap=False): ...
    def _get_aligned_spans(self, doc, spans, align, allow_overlap): ...
    def get_aligned_ents_and_ner(self): ...
    def get_aligned_ner(self): ...
    def get_matching_ents(self, check_label: bool = True) -> List[Span]: ...
    def to_dict(self) -> Dict[str, Any]: ...
    def _spans_to_dict(self) -> Dict[str, List[Tuple[int, int, str, str]]]: ...
    def _links_to_dict(self) -> Dict[Tuple[int, int], Dict[str, float]]: ...
    def split_sents(self) -> List[Example]: ...
    @property
    def text(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

def _annot2array(vocab, tok_annot, doc_annot): ...
def _add_spans_to_doc(doc, spans_data): ...
def _add_entities_to_doc(doc, ner_data): ...
def _parse_example_dict_data(example_dict): ...
def _fix_legacy_dict_data(example_dict): ...
def _has_field(annot, field) -> bool: ...
def _parse_ner_tags(biluo_or_offsets, vocab, words, spaces): ...
def _parse_links(vocab, words, spaces, links): ...
def _guess_spaces(text, words): ...
